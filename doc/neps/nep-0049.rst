===================================
NEP 49 â€” Data allocation strategies
===================================

:Author: Matti Picus
:Status: Draft
:Type: Standards Track
:Created: 2021-04-18


Abstract
--------

The ``numpy.ndarray`` requires additional memory allocations
to hold ``numpy.ndarray.strides``, ``numpy.ndarray.shape`` and
``numpy.ndarray.data`` attributes. These attributes are specially allocated
after creating the python object in ``__new__`` method. The ``strides`` and
``shape`` are stored in a piece of memory allocated internally.

These allocations are small relative to the ``data``, the homogeneous chunk of
memory used to store the actual array values (which could be pointers in the
case of ``object`` arrays). This NEP proposes a mechanism to override the
default memory management strategy in NumPy with user-provided alternatives.

Motivation and Scope
--------------------

Users may wish to override the internal data memory routines with ones of their
own. Two such use-cases are to ensure data alignment and to pin certain
allocations to certain NUMA cores.

User who wish to change the NumPy data memory management routines will use
:c:func:`PyDataMem_SetHandler`, which uses a :c:type:`PyDataMem_Handler`
structure to hold pointers to functions used to manage the data memory. The
calls are wrapped by internal routines to call :c:func:`PyTraceMalloc_Track`,
:c:func:`PyTraceMalloc_Untrack`, and will use the
:c:func:`PyDataMem_EventHookFunc` mechanism  already present in NumPy for
auditing purposes. 

Since a call to ``PyDataMem_SetHandler`` will change the default functions, but
that function may be called during the lifetime of an ``ndarray`` object, each
``ndarray`` will carry with it the ``PyDataMem_Handler`` struct used at the
time of its instantiation, and these will be used to reallocate or free the
data memory of the instance.

Usage and Impact
----------------

The new functions can only be accessed via the NumPy C-API. An example is
included later in the NEP. The added ``struct`` will increase the size of the
``ndarray`` object. It is one of the major drawbacks of this approach. We can
be reasonably sure that the change in size will have a minimal impact on
end-user code because NumPy version 1.20 already changed the object size.

Backward compatibility
----------------------

The design will not break backward compatibility. Projects that were assigning
to the ``ndarray->data`` pointer were already breaking the current memory
management strategy (backed by ``npy_alloc_cache``) and should restore
``ndarray->data`` before calling ``Py_DECREF``. As mentioned above, the change
in size should not impact end-users.

Detailed description
--------------------



NumPy C-API functions
=====================


.. c:type:: PyDataMem_Handler

    A struct to hold function pointers used to manipulate memory

    .. code-block:: c

        typedef struct {
            char name[128];  /* multiple of 64 to keep the struct unaligned */
            PyDataMem_AllocFunc *alloc;
            PyDataMem_ZeroedAllocFunc *zeroed_alloc;
            PyDataMem_FreeFunc *free;
            PyDataMem_ReallocFunc *realloc;
        } PyDataMem_Handler;

    where the function's signatures are

    .. code-block:: c

        typedef void *(PyDataMem_AllocFunc)(size_t size);
        typedef void *(PyDataMem_ZeroedAllocFunc)(size_t nelems, size_t elsize);
        typedef void (PyDataMem_FreeFunc)(void *ptr, size_t size);
        typedef void *(PyDataMem_ReallocFunc)(void *ptr, size_t size);
        typedef void *(PyDataMem_CopyFunc)(void *dst, const void *src, size_t size);

    Internally NumPy may use ``memcpy` or ``memset`` on the data ``ptr``.

.. c:function:: const PyDataMem_Handler * PyDataMem_SetHandler(PyDataMem_Handler *handler)

   Sets a new allocation policy. If the input value is NULL, will reset
   the policy to the default. Returns the previous policy, NULL if the
   previous policy was the default. We wrap the user-provided functions
   so they will still call the python and numpy memory management callback
   hooks.
    
.. c:function:: const char * PyDataMem_GetHandlerName(PyArrayObject *obj)

   Return the const char name of the PyDataMem_Handler used by the
   PyArrayObject. If NULL, return the name of the current global policy that
   will be used to allocate data for the next PyArrayObject

For an example of setting up and using the PyDataMem_Handler, see the test in
:file:`numpy/core/tests/test_mem_policy.py`

.. c:function:: void PyDataMem_EventHookFunc(void *inp, void *outp, size_t size, void *user_data);

    This function will be called on NEW,FREE,RENEW calls in data memory
    manipulation



.. c:function:: PyDataMem_EventHookFunc * PyDataMem_SetEventHook(PyDataMem_EventHookFunc *newhook, void *user_data, void **old_data)

    Sets the allocation event hook for numpy array data.
  
    Returns a pointer to the previous hook or NULL.  If old_data is
    non-NULL, the previous user_data pointer will be copied to it.
  
    If not NULL, hook will be called at the end of each PyDataMem_NEW/FREE/RENEW:

    .. code-block:: c
   
        result = PyDataMem_NEW(size)        -> (*hook)(NULL, result, size, user_data)
        PyDataMem_FREE(ptr)                 -> (*hook)(ptr, NULL, 0, user_data)
        result = PyDataMem_RENEW(ptr, size) -> (*hook)(ptr, result, size, user_data)
  
    When the hook is called, the GIL will be held by the calling
    thread.  The hook should be written to be reentrant, if it performs
    operations that might cause new allocation events (such as the
    creation/destruction numpy objects, or creating/destroying Python
    objects which might cause a gc)


Sample code
===========

Here is some sample code from the test added to the PR::

    #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
    #include <numpy/arrayobject.h>
    NPY_NO_EXPORT void *
    shift_alloc(size_t sz) {
        char *real = (char *)malloc(sz + 64);
        if (real == NULL) {
            return NULL;
        }
        snprintf(real, 64, "originally allocated %ld", (unsigned long)sz);
        return (void *)(real + 64);
    }
    NPY_NO_EXPORT void *
    shift_zero(size_t sz, size_t cnt) {
        char *real = (char *)calloc(sz + 64, cnt);
        if (real == NULL) {
            return NULL;
        }
        snprintf(real, 64, "originally allocated %ld via zero",
                 (unsigned long)sz);
        return (void *)(real + 64);
    }
    NPY_NO_EXPORT void
    shift_free(void * p, npy_uintp sz) {
        if (p == NULL) {
            return ;
        }
        char *real = (char *)p - 64;
        if (strncmp(real, "originally allocated", 20) != 0) {
            fprintf(stdout, "uh-oh, unmatched shift_free, "
                    "no appropriate prefix\\n");
            /* Make gcc crash by calling free on the wrong address */
            free((char *)p + 10);
            /* free(real); */
        }
        else {
            int i = atoi(real +20);
            if (i != sz) {
                fprintf(stderr, "uh-oh, unmatched "
                        "shift_free(ptr, %d) but allocated %d\\n", sz, i);
                /* Make gcc crash by calling free on the wrong address */
                /* free((char *)p + 10); */
                free(real);
            }
            else {
                free(real);
            }
        }
    }
    NPY_NO_EXPORT void *
    shift_realloc(void * p, npy_uintp sz) {
        if (p != NULL) {
            char *real = (char *)p - 64;
            if (strncmp(real, "originally allocated", 20) != 0) {
                fprintf(stdout, "uh-oh, unmatched shift_realloc\\n");
                return realloc(p, sz);
            }
            return (void *)((char *)realloc(real, sz + 64) + 64);
        }
        else {
            char *real = (char *)realloc(p, sz + 64);
            if (real == NULL) {
                return NULL;
            }
            snprintf(real, 64, "originally allocated "
                     "%ld  via realloc", (unsigned long)sz);
            return (void *)(real + 64);
        }
    }
    static PyDataMem_Handler new_handler = {
        "secret_data_allocator",
        shift_alloc,      /* alloc */
        shift_zero, /* zeroed_alloc */
        shift_free,       /* free */
        shift_realloc,      /* realloc */
        memcpy,               /* host2obj */
        memcpy,               /* obj2host */
        memcpy,               /* obj2obj */
    };

    static PyObject* mem_policy_test_prefix(PyObject *self, PyObject *args)
    {
    
        if (!PyArray_Check(args)) {
            PyErr_SetString(PyExc_ValueError,
                    "must be called with a numpy scalar or ndarray");
        }
        return PyUnicode_FromString(
                        PyDataMem_GetHandlerName((PyArrayObject*)args));
    
    };

    static PyObject* mem_policy_set_new_policy(PyObject *self, PyObject *args)
    {
    
         const PyDataMem_Handler *old = PyDataMem_SetHandler(&new_handler);
         return PyUnicode_FromString(old->name);
     
    };
    

    static PyObject* mem_policy_set_old_policy(PyObject *self, PyObject *args)
    {
    
         const PyDataMem_Handler *old = PyDataMem_SetHandler(NULL);
         return PyUnicode_FromString(old->name);
     
    };
        
    static PyMethodDef methods[] = {
    {"test_prefix", (PyCFunction)mem_policy_test_prefix, METH_O},
    {"set_new_policy", (PyCFunction)mem_policy_set_new_policy, METH_NOARGS},
    {"set_old_policy", (PyCFunction)mem_policy_set_old_policy, METH_NOARGS},
    { NULL }
    };

    static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "mem_policy",  /* m_name */
        NULL,           /* m_doc */
        -1,             /* m_size */
        methods,        /* m_methods */
    };

    PyMODINIT_FUNC
    PyInit_mem_policy(void) {
    PyObject *mod = PyModule_Create(&moduledef);
        import_array();
        return mod;
    }
 

Related Work
------------

The NEP is being tracked by the pnumpy_ project and a `comment in the PR`_
mentions use in orchestrating FPGA DMAs.

Implementation
--------------

The NEP has been implemented in `PR  17582`_.

Alternatives
------------

These were discussed in `issue 17467`_. `PR 5457`_ proposed a
global interface for specifying aligned allocations. Alignment can be
crucial for some applications, but in general is just extra overhead, so it
should be configurable by the user/app. ``PyArray_malloc_aligned`` and
friends were added to NumPy with the random API refactor. and are used there
for performance.

`PR 5470`_ had two parts: configurable `PyDataMem*` overrides and a hook
mechanism. The hook mechanism was merged (does anyone use that?) but the
part described by this NEP would still requre an API change.

Discussion
----------

Not yet discussed on the mailing list.


References and Footnotes
------------------------

.. [1] Each NEP must either be explicitly labeled as placed in the public domain (see
   this NEP as an example) or licensed under the `Open Publication License`_.

.. _Open Publication License: https://www.opencontent.org/openpub/

.. _`PR 17582`: https://github.com/numpy/numpy/pull/17582
.. _`PR 5457`: https://github.com/numpy/numpy/pull/5457
.. _`PR 5470`: https://github.com/numpy/numpy/pull/5470
.. _`issue 17467`: https://github.com/numpy/numpy/issues/17467
.. _`comment in the PR`: https://github.com/numpy/numpy/pull/17582#issuecomment-809145547
.. _pnumpy: https://quansight.github.io/pnumpy/stable/index.html

Copyright
---------

This document has been placed in the public domain. [1]_
