# This file is generated by numpy's build process
# It contains system_info results at the time of building this package.
from enum import Enum
from numpy.core._multiarray_umath import (
    __cpu_features__,
    __cpu_baseline__,
    __cpu_dispatch__,
)

__all__ = ["show"]


class DisplayModes(Enum):
    print = "print"
    json = "json"


def _cleanup(d):
    """
    Removes empty values in a `dict` recursively
    This ensures we remove values that Meson could not provide to CONFIG
    """
    if type(d) is dict:
        return dict((k, _cleanup(v)) for k, v in d.items() if v and _cleanup(v))
    else:
        return d


CONFIG = _cleanup(
    {
        "Compilers": {
            "c": {
                "name": "@C_COMP@",
                "linker": "@C_COMP_LINKER_ID@",
                "version": "@C_COMP_VERSION@",
                "commands": "@C_COMP_CMD_ARRAY@",
            },
            "cython": {
                "name": "@CYTHON_COMP@",
                "linker": "@CYTHON_COMP_LINKER_ID@",
                "version": "@CYTHON_COMP_VERSION@",
                "commands": "@CYTHON_COMP_CMD_ARRAY@",
            },
            "c++": {
                "name": "@CPP_COMP@",
                "linker": "@CPP_COMP_LINKER_ID@",
                "version": "@CPP_COMP_VERSION@",
                "commands": "@CPP_COMP_CMD_ARRAY@",
            },
        },
        "Machine Information": {
            "host": {
                "cpu": "@HOST_CPU@",
                "family": "@HOST_CPU_FAMILY@",
                "endian": "@HOST_CPU_ENDIAN@",
                "system": "@HOST_CPU_SYSTEM@",
            },
            "build": {
                "cpu": "@BUILD_CPU@",
                "family": "@BUILD_CPU_FAMILY@",
                "endian": "@BUILD_CPU_ENDIAN@",
                "system": "@BUILD_CPU_SYSTEM@",
            },
            "target": {
                "cpu": "@TARGET_CPU@",
                "family": "@TARGET_CPU_FAMILY@",
                "endian": "@TARGET_CPU_ENDIAN@",
                "system": "@TARGET_CPU_SYSTEM@",
            },
        },
        "Build Dependencies": {
            "blas": {
                "name": "@BLAS_NAME@",
                "found": "@BLAS_FOUND@",
                "version": "@BLAS_VERSION@",
                "type name": "@BLAS_TYPE_NAME@",
                "includedir": "@BLAS_INCLUDEDIR@",
                "libdir": "@BLAS_LIBDIR@",
                "openblas config": "@BLAS_OPENBLAS_CONFIG@",
                "pc file directory": "@BLAS_PCFILEDIR@",
            },
            "lapack": {
                "name": "@LAPACK_NAME@",
                "found": "@LAPACK_FOUND@",
                "version": "@LAPACK_VERSION@",
                "type_name": "@LAPACK_TYPE_NAME@",
                "includedir": "@LAPACK_INCLUDEDIR@",
                "libdir": "@LAPACK_LIBDIR@",
                "openblas_config": "@LAPACK_OPENBLAS_CONFIG@",
                "pc file directory": "@LAPACK_PCFILEDIR@",
            },
        },
        "Python Information": {
            "path": "@PYTHON_PATH@",
            "version": "@PYTHON_VERSION@",
        },
        "SIMD Extensions": {
            "baseline": __cpu_baseline__,
            "found": [
                feature for feature in __cpu_dispatch__ if __cpu_features__[feature]
            ],
            "not found": [
                feature for feature in __cpu_dispatch__ if not __cpu_features__[feature]
            ],
        },
    }
)


def show(mode="print"):
    if mode == DisplayModes.print.value:
        try:  # Non-standard library, check import
            import yaml

            print(yaml.dump(CONFIG))
        except ModuleNotFoundError:
            import warnings
            import json

            warnings.warn("Install `pyyaml` for better output", stacklevel=1)
            print(json.dumps(CONFIG, indent=2))
    elif mode == DisplayModes.json.value:
        return CONFIG
    else:
        raise
