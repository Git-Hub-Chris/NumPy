/*
 * This file provides optimized sum of product implementations used internally
 * by einsum.
 *
 * Copyright (c) 2011 by Mark Wiebe (mwwiebe@gmail.com)
 * The University of British Columbia
 *
 * See LICENSE.txt for the license.
 */

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#define _MULTIARRAYMODULE
#include <numpy/halffloat.h>
#include "einsum_sumprod.h"
#include "einsum_debug.h"
#include "simd/simd.h"
#include "common.h"

// ARM/Neon don't have instructions for aligned memory access
#ifdef NPY_HAVE_NEON
    #define EINSUM_IS_ALIGNED(x) 0
#else
    #define EINSUM_IS_ALIGNED(x) npy_is_aligned(x, NPY_SIMD_WIDTH)
#endif

/**
 * Unroll by four/eight scalars in case of:
 *  - The main SIMD loop un-rolled by NPY_SIMD_WIDTH*(2|4), (2|4) represents
 *    the number of times the loop that unrolled, Eg: for float32, 2 simd loop
 *    is unrolled, for float64, 4 simd loop is unrolled, which may lead to
 *    un-vectorize the remained scalars in bytes range <=NPY_SIMD_WIDTH*(2|4)
 *    if The SIMD width is higher than 128bit, The performance loss on remained
 *    arrays is nonnegligible, so we choose to use the compiler auto-vectorize.
 *  - To give the chance to the compiler to
 *    auto-vectorize in case of NPYV wasn't available.
 */
#define EINSUM_UNROLL_4_SCALARS(CHK) (!defined(NPY_DISABLE_OPTIMIZATION) && (!(CHK) || NPY_SIMD > 128))

/**begin repeat
 * #name = byte, short, int, long, longlong,
 *         ubyte, ushort, uint, ulong, ulonglong,
 *         half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_byte, npy_short, npy_int, npy_long, npy_longlong,
 *         npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble#
 * #temptype = npy_byte, npy_short, npy_int, npy_long, npy_longlong,
 *             npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong,
 *             npy_float, npy_float, npy_double, npy_longdouble,
 *             npy_float, npy_double, npy_longdouble#
* #sfx  = s8, s16, s32, long, s64,
 *        u8, u16, u32, ulong, u64,
 *        half, f32, f64, longdouble,
 *        f32, f64, clongdouble#
 * #to = ,,,,,
 *       ,,,,,
 *       npy_float_to_half,,,,
 *       ,,#
 * #from = ,,,,,
 *         ,,,,,
 *         npy_half_to_float,,,,
 *         ,,#
 * #complex = 0*5,
 *            0*5,
 *            0*4,
 *            1*3#
 * #float32 = 0*5,
 *            0*5,
 *            0,1,0,0,
 *            0*3#
 * #float64 = 0*5,
 *            0*5,
 *            0,0,1,0,
 *            0*3#
 * #NPYV_CHK = 0*5,
 *             0*5,
 *             0, NPY_SIMD, NPY_SIMD_F64, 0,
 *             0*3#
 * #unroll_by = 0*5,
 *              0*5,
 *              0,2, 4, 0,
 *              0*3#
 */
/**begin repeat1
 * #nop = 1, 2, 3, 1000#
 * #noplabel = one, two, three, any#
 */
static void
@name@_sum_of_products_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3) && !@complex@
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3) && !@complex@
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data_out = dataptr[@nop@];
    npy_intp stride_out = strides[@nop@];
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_@noplabel@ (%d)\n", (int)count);

    while (count--) {
#if !@complex@
#  if @nop@ == 1
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif @nop@ == 2
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) *
                                         @from@(*(@type@ *)data1) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif @nop@ == 3
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) *
                                         @from@(*(@type@ *)data1) *
                                         @from@(*(@type@ *)data2) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        *(@type@ *)dataptr[nop] = @to@(temp +
                                           @from@(*(@type@ *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if @nop@ == 1
        ((@temptype@ *)data_out)[0] = ((@temptype@ *)data0)[0] +
                                         ((@temptype@ *)data_out)[0];
        ((@temptype@ *)data_out)[1] = ((@temptype@ *)data0)[1] +
                                         ((@temptype@ *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if @nop@ <= 3
#define _SUMPROD_NOP @nop@
#    else
#define _SUMPROD_NOP nop
#    endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[0];
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if @nop@ == 1

static void
@name@_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data_out = (@type@ *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
/**begin repeat2
 * #i = 6, 5, 4, 3, 2, 1, 0#
 */
        case @i@+1:
#if !@complex@
            data_out[@i@] = @to@(@from@(data0[@i@]) +
                                 @from@(data_out[@i@]));
#else
            ((@temptype@ *)data_out + 2*@i@)[0] =
                                    ((@temptype@ *)data0 + 2*@i@)[0] +
                                    ((@temptype@ *)data_out + 2*@i@)[0];
            ((@temptype@ *)data_out + 2*@i@)[1] =
                                    ((@temptype@ *)data0 + 2*@i@)[1] +
                                    ((@temptype@ *)data_out + 2*@i@)[1];
#endif
/**end repeat2**/
        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
#if !@complex@
        data_out[@i@] = @to@(@from@(data0[@i@]) +
                             @from@(data_out[@i@]));
#else /* complex */
        ((@temptype@ *)data_out + 2*@i@)[0] =
                                ((@temptype@ *)data0 + 2*@i@)[0] +
                                ((@temptype@ *)data_out + 2*@i@)[0];
        ((@temptype@ *)data_out + 2*@i@)[1] =
                                ((@temptype@ *)data0 + 2*@i@)[1] +
                                ((@temptype@ *)data_out + 2*@i@)[1];
#endif
/**end repeat2**/
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif @nop@ == 2 && !@complex@

static void
@name@_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data_out = (@type@ *)dataptr[2];
    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_two (%d)\n",
                                                            (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1) &&
                        EINSUM_IS_ALIGNED(data_out);
    const int vstep = npyv_nlanes_@sfx@;

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data0 += vstepx4, data1 += vstepx4, data_out += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ a@i@ = npyv_@ld@_@sfx@(data0 + vstep * @i@);
            npyv_@sfx@ b@i@ = npyv_@ld@_@sfx@(data1 + vstep * @i@);
            npyv_@sfx@ c@i@ = npyv_@ld@_@sfx@(data_out + vstep * @i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ abc@i@ = npyv_muladd_@sfx@(a@i@, b@i@, c@i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@st@_@sfx@(data_out + vstep * @i@, abc@i@);
            /**end repeat3**/
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data0 += vstepx2, data1 += vstepx2, data_out += vstepx2) {
            npyv_@sfx@ a0 = npyv_@ld@_@sfx@(data0);
            npyv_@sfx@ a1 = npyv_@ld@_@sfx@(data0 + vstep);
            npyv_@sfx@ b0 = npyv_@ld@_@sfx@(data1);
            npyv_@sfx@ b1 = npyv_@ld@_@sfx@(data1 + vstep);
            npyv_@sfx@ c0 = npyv_@ld@_@sfx@(data_out);
            npyv_@sfx@ c1 = npyv_@ld@_@sfx@(data_out + vstep);
            npyv_@sfx@ abc0 = npyv_muladd_@sfx@(a0, b0, c0);
            npyv_@sfx@ abc1 = npyv_muladd_@sfx@(a1, b1, c1);
            npyv_@st@_@sfx@(data_out, abc0);
            npyv_@st@_@sfx@(data_out + vstep, abc1);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data0 += 4, data1 += 4, data_out += 4) {
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ a@i@ = @from@(data0[@i@]);
        const @type@ b@i@ = @from@(data1[@i@]);
        const @type@ c@i@ = @from@(data_out[@i@]);
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ abc@i@ = a@i@ * b@i@ + c@i@;
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        data_out[@i@] = @to@(abc@i@);
        /**end repeat2**/
    }
#endif
    for (; count > 0; --count, ++data0, ++data1, ++data_out) {
        const @type@ a = @from@(*data0);
        const @type@ b = @from@(*data1);
        const @type@ c = @from@(*data_out);
        *data_out = @to@(a * b + c);
    }
}

/* Some extra specializations for the two operand case */
static void
@name@_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @temptype@ a_scalar = @from@(*(@type@ *)dataptr[0]);
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data_out = (@type@ *)dataptr[2];

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data1) && EINSUM_IS_ALIGNED(data_out);
    const int vstep = npyv_nlanes_@sfx@;
    const npyv_@sfx@ va_scalar = npyv_setall_@sfx@(a_scalar);

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data1 += vstepx4, data_out += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ b@i@ = npyv_@ld@_@sfx@(data1 + vstep * @i@);
            npyv_@sfx@ c@i@ = npyv_@ld@_@sfx@(data_out + vstep * @i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ abc@i@ = npyv_muladd_@sfx@(va_scalar, b@i@, c@i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@st@_@sfx@(data_out + vstep * @i@, abc@i@);
            /**end repeat3**/
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data1 += vstepx2, data_out += vstepx2) {
            npyv_@sfx@ b0 = npyv_@ld@_@sfx@(data1);
            npyv_@sfx@ b1 = npyv_@ld@_@sfx@(data1 + vstep);
            npyv_@sfx@ c0 = npyv_@ld@_@sfx@(data_out);
            npyv_@sfx@ c1 = npyv_@ld@_@sfx@(data_out + vstep);
            npyv_@sfx@ abc0 = npyv_muladd_@sfx@(va_scalar, b0, c0);
            npyv_@sfx@ abc1 = npyv_muladd_@sfx@(va_scalar, b1, c1);
            npyv_@st@_@sfx@(data_out, abc0);
            npyv_@st@_@sfx@(data_out + vstep, abc1);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data1 += 4, data_out += 4) {
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ b@i@ = @from@(data1[@i@]);
        const @type@ c@i@ = @from@(data_out[@i@]);
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ abc@i@ = a_scalar * b@i@ + c@i@;
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        data_out[@i@] = @to@(abc@i@);
        /**end repeat2**/
    }
#endif
    for (; count > 0; --count, ++data1, ++data_out) {
        const @type@ b = @from@(*data1);
        const @type@ c = @from@(*data_out);
        *data_out = @to@(a_scalar * b + c);
    }
}

static void
@name@_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @temptype@ b_scalar = @from@(*(@type@ *)dataptr[1]);
    @type@ *data_out = (@type@ *)dataptr[2];
    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data_out);
    const int vstep = npyv_nlanes_@sfx@;
    const npyv_@sfx@ vb_scalar = npyv_setall_@sfx@(b_scalar);

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data0 += vstepx4, data_out += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ a@i@ = npyv_@ld@_@sfx@(data0 + vstep * @i@);
            npyv_@sfx@ c@i@ = npyv_@ld@_@sfx@(data_out + vstep * @i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ abc@i@ = npyv_muladd_@sfx@(a@i@, vb_scalar, c@i@);
            /**end repeat3**/
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@st@_@sfx@(data_out + vstep * @i@, abc@i@);
            /**end repeat3**/
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data0 += vstepx2, data_out += vstepx2) {
            npyv_@sfx@ a0 = npyv_@ld@_@sfx@(data0);
            npyv_@sfx@ a1 = npyv_@ld@_@sfx@(data0 + vstep);
            npyv_@sfx@ c0 = npyv_@ld@_@sfx@(data_out);
            npyv_@sfx@ c1 = npyv_@ld@_@sfx@(data_out + vstep);
            npyv_@sfx@ abc0 = npyv_muladd_@sfx@(a0, vb_scalar, c0);
            npyv_@sfx@ abc1 = npyv_muladd_@sfx@(a1, vb_scalar, c1);
            npyv_@st@_@sfx@(data_out, abc0);
            npyv_@st@_@sfx@(data_out + vstep, abc1);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data0 += 4, data_out += 4) {
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ a@i@ = @from@(data0[@i@]);
        const @type@ c@i@ = @from@(data_out[@i@]);
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ abc@i@ = a@i@ * b_scalar + c@i@;
        /**end repeat2**/
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        data_out[@i@] = @to@(abc@i@);
        /**end repeat2**/
    }
#endif
    for (; count > 0; --count, ++data0, ++data_out) {
        const @type@ a = @from@(*data0);
        const @type@ c = @from@(*data_out);
        *data_out = @to@(a * b_scalar + c);
    }
}

static void
@name@_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @temptype@ accum = 0;

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1);
    const int vstep = npyv_nlanes_@sfx@;
    npyv_@sfx@ vaccum = npyv_zero_@sfx@();

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data0 += vstepx4, data1 += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ a@i@ = npyv_@ld@_@sfx@(data0 + vstep * @i@);
            npyv_@sfx@ b@i@ = npyv_@ld@_@sfx@(data1 + vstep * @i@);
            /**end repeat3**/
            npyv_@sfx@ ab3 = npyv_muladd_@sfx@(a3, b3, vaccum);
            npyv_@sfx@ ab2 = npyv_muladd_@sfx@(a2, b2, ab3);
            npyv_@sfx@ ab1 = npyv_muladd_@sfx@(a1, b1, ab2);
                    vaccum = npyv_muladd_@sfx@(a0, b0, ab1);
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data0 += vstepx2, data1 += vstepx2) {
            npyv_@sfx@ a0 = npyv_@ld@_@sfx@(data0);
            npyv_@sfx@ a1 = npyv_@ld@_@sfx@(data0 + vstep);
            npyv_@sfx@ b0 = npyv_@ld@_@sfx@(data1);
            npyv_@sfx@ b1 = npyv_@ld@_@sfx@(data1 + vstep);
            npyv_@sfx@ ab1 = npyv_muladd_@sfx@(a1, b1, vaccum);
                    vaccum = npyv_muladd_@sfx@(a0, b0, ab1);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    accum = npyv_sum_@sfx@(vaccum);
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data0 += 4, data1 += 4) {
        /**begin repeat2
         * #i = 0, 1, 2, 3#
         */
        const @type@ ab@i@ = @from@(data0[@i@]) * @from@(data1[@i@]);
        /**end repeat2**/
        accum += ab0 + ab1 + ab2 + ab3;
    }
#endif
    for (; count > 0; --count, ++data0, ++data1) {
        const @type@ a = @from@(*data0);
        const @type@ b = @from@(*data1);
        accum += a * b;
    }
    *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + accum);
}

static void
@name@_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @temptype@ a_scalar = @from@(*(@type@ *)dataptr[0]);
    @type@ *data1 = (@type@ *)dataptr[1];
    @temptype@ accum = 0;

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data1);
    const int vstep = npyv_nlanes_@sfx@;
    npyv_@sfx@ vaccum = npyv_zero_@sfx@();

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data1 += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ b@i@ = npyv_@ld@_@sfx@(data1 + vstep * @i@);
            /**end repeat3**/
            npyv_@sfx@ b01   = npyv_add_@sfx@(b0, b1);
            npyv_@sfx@ b23   = npyv_add_@sfx@(b2, b3);
            npyv_@sfx@ b0123 = npyv_add_@sfx@(b01, b23);
                      vaccum = npyv_add_@sfx@(b0123, vaccum);
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data1 += vstepx2) {
            npyv_@sfx@ b0 = npyv_@ld@_@sfx@(data1);
            npyv_@sfx@ b1 = npyv_@ld@_@sfx@(data1 + vstep);
            npyv_@sfx@ b01 = npyv_add_@sfx@(b0, b1);
                    vaccum = npyv_add_@sfx@(b01, vaccum);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    accum = npyv_sum_@sfx@(vaccum);
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data1 += 4) {
        const @type@ b01 = @from@(data1[0]) + @from@(data1[1]);
        const @type@ b23 = @from@(data1[2]) + @from@(data1[3]);
        accum += b01 + b23;
    }
#endif
    for (; count > 0; --count, ++data1) {
        accum += @from@(*data1);
    }
    *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + a_scalar * accum);
}

static void
@name@_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @temptype@ b_scalar = @from@(*(@type@ *)dataptr[1]);
    @temptype@ accum = 0;
    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data0);
    const int vstep = npyv_nlanes_@sfx@;
    npyv_@sfx@ vaccum = npyv_zero_@sfx@();

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data0 += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ a@i@ = npyv_@ld@_@sfx@(data0 + vstep * @i@);
            /**end repeat3**/
            npyv_@sfx@ a01   = npyv_add_@sfx@(a0, a1);
            npyv_@sfx@ a23   = npyv_add_@sfx@(a2, a3);
            npyv_@sfx@ a0123 = npyv_add_@sfx@(a01, a23);
                      vaccum = npyv_add_@sfx@(a0123, vaccum);
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data0 += vstepx2) {
            npyv_@sfx@ a0 = npyv_@ld@_@sfx@(data0);
            npyv_@sfx@ a1 = npyv_@ld@_@sfx@(data0 + vstep);
            npyv_@sfx@ a01 = npyv_add_@sfx@(a0, a1);
                    vaccum = npyv_add_@sfx@(a01, vaccum);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    accum = npyv_sum_@sfx@(vaccum);
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    for (; count >= 4; count -= 4, data0 += 4) {
        const @type@ a01 = @from@(data0[0]) + @from@(data0[1]);
        const @type@ a23 = @from@(data0[2]) + @from@(data0[3]);
        accum += a01 + a23;
    }
#endif
    for (; count > 0; --count, ++data0) {
        accum += @from@(*data0);
    }
    *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + b_scalar * accum);
}

#elif @nop@ == 3 && !@complex@

static void
@name@_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data2 = (@type@ *)dataptr[2];
    @type@ *data_out = (@type@ *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        data_out[@i@] = @to@(@from@(data0[@i@]) *
                             @from@(data1[@i@]) *
                             @from@(data2[@i@]) +
                             @from@(data_out[@i@]));
/**end repeat2**/
        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
    if (count-- == 0) {
        return;
    }
    data_out[@i@] = @to@(@from@(data0[@i@]) *
                         @from@(data1[@i@]) *
                         @from@(data2[@i@]) +
                         @from@(data_out[@i@]));
/**end repeat2**/
}

#else /* @nop@ > 3 || @complex */

static void
@name@_sum_of_products_contig_@noplabel@(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_@noplabel@ (%d)\n",
                                                    (int)count);

    while (count--) {
#if !@complex@
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        *(@type@ *)dataptr[nop] = @to@(temp +
                                           @from@(*(@type@ *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(@type@);
        }
#else /* complex */
#  if @nop@ <= 3
#    define _SUMPROD_NOP @nop@
#  else
#    define _SUMPROD_NOP nop
#  endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[0];
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(@type@);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various @nop@ */

#if @nop@ == 1

static void
@name@_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if @complex@
    @temptype@ accum_re = 0, accum_im = 0;
    @temptype@ *data0 = (@temptype@ *)dataptr[0];
#else
    @temptype@ accum = 0;
    @type@ *data0 = (@type@ *)dataptr[0];
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_outstride0_one (%d)\n", (int)count);
#if @NPYV_CHK@ // NPYV check for @type@
    /* Use aligned instructions if possible */
    const int is_aligned = EINSUM_IS_ALIGNED(data0);
    const int vstep = npyv_nlanes_@sfx@;
    npyv_@sfx@ vaccum = npyv_zero_@sfx@();

    /**begin repeat2
     * #cond = if(is_aligned), else#
     * #ld = loada, load#
     * #st = storea, store#
     */
    @cond@ {
    #if @unroll_by@ == 4
        const npy_intp vstepx4 = vstep * 4;
        for (; count >= vstepx4; count -= vstepx4, data0 += vstepx4) {
            /**begin repeat3
             * #i = 0, 1, 2, 3#
             */
            npyv_@sfx@ a@i@ = npyv_@ld@_@sfx@(data0 + vstep * @i@);
            /**end repeat3**/
            npyv_@sfx@ a01   = npyv_add_@sfx@(a0, a1);
            npyv_@sfx@ a23   = npyv_add_@sfx@(a2, a3);
            npyv_@sfx@ a0123 = npyv_add_@sfx@(a01, a23);
                      vaccum = npyv_add_@sfx@(a0123, vaccum);
        }
    #elif @unroll_by@ == 2
        const npy_intp vstepx2 = vstep * 2;
        for (; count >= vstepx2; count -= vstepx2, data0 += vstepx2) {
            npyv_@sfx@ a0 = npyv_@ld@_@sfx@(data0);
            npyv_@sfx@ a1 = npyv_@ld@_@sfx@(data0 + vstep);
            npyv_@sfx@ a01 = npyv_add_@sfx@(a0, a1);
                    vaccum = npyv_add_@sfx@(a01, vaccum);
        }
    #else
        #error "Invalid unroll_by = @unroll_by@"
    #endif
    }
    /**end repeat2**/
    accum = npyv_sum_@sfx@(vaccum);
    npyv_cleanup();
#endif // NPYV check for @type@

#if EINSUM_UNROLL_4_SCALARS(@NPYV_CHK@)
    #if @complex@
        for (; count > 4; count -= 4, data0 += 4*2) {
            const @temptype@ re01 = data0[0] + data0[2];
            const @temptype@ re23 = data0[4] + data0[6];
            const @temptype@ im13 = data0[1] + data0[3];
            const @temptype@ im57 = data0[5] + data0[7];
            accum_re += re01 + re23;
            accum_im += im13 + im57;
        }
    #else
        for (; count > 4; count -= 4, data0 += 4) {
            const @temptype@ a01 = @from@(data0[0]) + @from@(data0[1]);
            const @temptype@ a23 = @from@(data0[2]) + @from@(data0[3]);
            accum +=  a01 + a23;
        }
    #endif  // complex
#endif
#if @complex@
    for (; count > 0; --count, data0 += 2) {
        accum_re += data0[0];
        accum_im += data0[1];
    }
    ((@temptype@ *)dataptr[1])[0] += accum_re;
    ((@temptype@ *)dataptr[1])[1] += accum_im;
#else
    for (; count > 0; --count, ++data0) {
        accum += @from@(*data0);
    }
    *((@type@ *)dataptr[1]) = @to@(accum + @from@(*((@type@ *)dataptr[1])));
#endif // complex
}

#endif /* @nop@ == 1 */

static void
@name@_sum_of_products_outstride0_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if @complex@
    @temptype@ accum_re = 0, accum_im = 0;
#else
    @temptype@ accum = 0;
#endif

#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3) && !@complex@
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3) && !@complex@
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_outstride0_@noplabel@ (%d)\n",
                                                    (int)count);

    while (count--) {
#if !@complex@
#  if @nop@ == 1
        accum += @from@(*(@type@ *)data0);
        data0 += stride0;
#  elif @nop@ == 2
        accum += @from@(*(@type@ *)data0) *
                 @from@(*(@type@ *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif @nop@ == 3
        accum += @from@(*(@type@ *)data0) *
                 @from@(*(@type@ *)data1) *
                 @from@(*(@type@ *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if @nop@ == 1
        accum_re += ((@temptype@ *)data0)[0];
        accum_im += ((@temptype@ *)data0)[1];
        data0 += stride0;
#  else
#    if @nop@ <= 3
#define _SUMPROD_NOP @nop@
#    else
#define _SUMPROD_NOP nop
#    endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if @complex@
#  if @nop@ <= 3
    ((@temptype@ *)dataptr[@nop@])[0] += accum_re;
    ((@temptype@ *)dataptr[@nop@])[1] += accum_im;
#  else
    ((@temptype@ *)dataptr[nop])[0] += accum_re;
    ((@temptype@ *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if @nop@ <= 3
    *((@type@ *)dataptr[@nop@]) = @to@(accum +
                                    @from@(*((@type@ *)dataptr[@nop@])));
#  else
    *((@type@ *)dataptr[nop]) = @to@(accum +
                                    @from@(*((@type@ *)dataptr[nop])));
#  endif
#endif

}

/**end repeat1**/

/**end repeat**/


/* Do OR of ANDs for the boolean type */

/**begin repeat
 * #nop = 1, 2, 3, 1000#
 * #noplabel = one, two, three, any#
 */

static void
bool_sum_of_products_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (@nop@ <= 3)
    char *data_out = dataptr[@nop@];
    npy_intp stride_out = strides[@nop@];
#endif

    while (count--) {
#if @nop@ == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif @nop@ == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif @nop@ == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ <= 3)
    char *data0 = dataptr[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
#endif
#if (@nop@ <= 3)
    char *data_out = dataptr[@nop@];
#endif

#if (@nop@ <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
/**begin repeat1
 * #i = 6, 5, 4, 3, 2, 1, 0#
 */
        case @i@+1:
#  if @nop@ == 1
            ((npy_bool *)data_out)[@i@] = ((npy_bool *)data0)[@i@] ||
                                            ((npy_bool *)data_out)[@i@];
#  elif @nop@ == 2
            ((npy_bool *)data_out)[@i@] =
                            (((npy_bool *)data0)[@i@] &&
                             ((npy_bool *)data1)[@i@]) ||
                                ((npy_bool *)data_out)[@i@];
#  elif @nop@ == 3
            ((npy_bool *)data_out)[@i@] =
                           (((npy_bool *)data0)[@i@] &&
                            ((npy_bool *)data1)[@i@] &&
                            ((npy_bool *)data2)[@i@]) ||
                                ((npy_bool *)data_out)[@i@];
#  endif
/**end repeat1**/
        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (@nop@ <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if @nop@ == 1
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) = (*((npy_bool *)data0 + @i@)) ||
                                        (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif @nop@ == 2
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) =
                        ((*((npy_bool *)data0 + @i@)) &&
                         (*((npy_bool *)data1 + @i@))) ||
                            (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif @nop@ == 3
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) =
                       ((*((npy_bool *)data0 + @i@)) &&
                        (*((npy_bool *)data1 + @i@)) &&
                        (*((npy_bool *)data2 + @i@))) ||
                            (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (@nop@ <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (@nop@ <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if @nop@ == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif @nop@ == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif @nop@ == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if @nop@ <= 3
    *((npy_bool *)dataptr[@nop@]) = accum || *((npy_bool *)dataptr[@nop@]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}

/**end repeat**/

/* These tables need to match up with the type enum */
static sum_of_products_fn
_contig_outstride0_unary_specialization_table[NPY_NTYPES] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 0,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
    &@name@_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif
/**end repeat**/
}; /* End of _contig_outstride0_unary_specialization_table */

static sum_of_products_fn _binary_specialization_table[NPY_NTYPES][5] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 0,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        0, 0, 0,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_stride0_contig_outstride0_two,
    &@name@_sum_of_products_stride0_contig_outcontig_two,
    &@name@_sum_of_products_contig_stride0_outstride0_two,
    &@name@_sum_of_products_contig_stride0_outcontig_two,
    &@name@_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _binary_specialization_table */

static sum_of_products_fn _outstride0_specialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_outstride0_any,
    &@name@_sum_of_products_outstride0_one,
    &@name@_sum_of_products_outstride0_two,
    &@name@_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _outstride0_specialized_table */

static sum_of_products_fn _allcontig_specialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_contig_any,
    &@name@_sum_of_products_contig_one,
    &@name@_sum_of_products_contig_two,
    &@name@_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _allcontig_specialized_table */

static sum_of_products_fn _unspecialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_any,
    &@name@_sum_of_products_one,
    &@name@_sum_of_products_two,
    &@name@_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _unnspecialized_table */

NPY_VISIBILITY_HIDDEN sum_of_products_fn
get_sum_of_products_function(int nop, int type_num,
                             npy_intp itemsize, npy_intp const *fixed_strides)
{
    int iop;

    if (type_num >= NPY_NTYPES) {
        return NULL;
    }

    /* contiguous reduction */
    if (nop == 1 && fixed_strides[0] == itemsize && fixed_strides[1] == 0) {
        sum_of_products_fn ret =
            _contig_outstride0_unary_specialization_table[type_num];
        if (ret != NULL) {
            return ret;
        }
    }

    /* nop of 2 has more specializations */
    if (nop == 2) {
        /* Encode the zero/contiguous strides */
        int code;
        code = (fixed_strides[0] == 0) ? 0 :
                    (fixed_strides[0] == itemsize) ? 2*2*1 : 8;
        code += (fixed_strides[1] == 0) ? 0 :
                    (fixed_strides[1] == itemsize) ? 2*1 : 8;
        code += (fixed_strides[2] == 0) ? 0 :
                    (fixed_strides[2] == itemsize) ? 1 : 8;
        if (code >= 2 && code < 7) {
            sum_of_products_fn ret =
                        _binary_specialization_table[type_num][code-2];
            if (ret != NULL) {
                return ret;
            }
        }
    }

    /* Inner loop with an output stride of 0 */
    if (fixed_strides[nop] == 0) {
        return _outstride0_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* Check for all contiguous */
    for (iop = 0; iop < nop + 1; ++iop) {
        if (fixed_strides[iop] != itemsize) {
            break;
        }
    }

    /* Contiguous loop */
    if (iop == nop + 1) {
        return _allcontig_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* None of the above specializations caught it, general loops */
    return _unspecialized_table[type_num][nop <= 3 ? nop : 0];
}
