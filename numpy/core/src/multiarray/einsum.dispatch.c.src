/*
 * This file contains the implementation of the 'einsum' function,
 * which provides an einstein-summation operation.
 *
 * Copyright (c) 2011 by Mark Wiebe (mwwiebe@gmail.com)
 * The University of British Columbia
 *
 * See LICENSE.txt for the license.
 */
/**
 * @targets $werror baseline
 * SSE2 SSE41 AVX2
 * NEON ASIMD ASIMDHP
 */
#include "einsum_p.h"

#if NPY_SIMD || NPY_SIMD_F64
    #if NPY_SIMD_WIDTH > 32
        #define UNROLL_BY npyv_nlanes_f64 * 2
    #else
        #define UNROLL_BY npyv_nlanes_f64 * 4
    #endif
#else
    #define UNROLL_BY 8
#endif

/**begin repeat
 * #name = byte, short, int, long, longlong,
 *         ubyte, ushort, uint, ulong, ulonglong,
 *         half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_byte, npy_short, npy_int, npy_long, npy_longlong,
 *         npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble#
 * #temptype = npy_byte, npy_short, npy_int, npy_long, npy_longlong,
 *             npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong,
 *             npy_float, npy_float, npy_double, npy_longdouble,
 *             npy_float, npy_double, npy_longdouble#
 * #to = ,,,,,
 *       ,,,,,
 *       npy_float_to_half,,,,
 *       ,,#
 * #from = ,,,,,
 *         ,,,,,
 *         npy_half_to_float,,,,
 *         ,,#
 * #complex = 0*5,
 *            0*5,
 *            0*4,
 *            1*3#
 * #float32 = 0*5,
 *            0*5,
 *            0,1,0,0,
 *            0*3#
 * #float64 = 0*5,
 *            0*5,
 *            0,0,1,0,
 *            0*3#
 */

/**begin repeat1
 * #nop = 1, 2, 3, 1000#
 * #noplabel = one, two, three, any#
 */
static void
@name@_sum_of_products_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3) && !@complex@
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3) && !@complex@
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data_out = dataptr[@nop@];
    npy_intp stride_out = strides[@nop@];
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_@noplabel@ (%d)\n", (int)count);

    while (count--) {
#if !@complex@
#  if @nop@ == 1
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data_out += stride_out;
#  elif @nop@ == 2
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) *
                                         @from@(*(@type@ *)data1) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#  elif @nop@ == 3
        *(@type@ *)data_out = @to@(@from@(*(@type@ *)data0) *
                                         @from@(*(@type@ *)data1) *
                                         @from@(*(@type@ *)data2) +
                                         @from@(*(@type@ *)data_out));
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#  else
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        *(@type@ *)dataptr[nop] = @to@(temp +
                                           @from@(*(@type@ *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if @nop@ == 1
        ((@temptype@ *)data_out)[0] = ((@temptype@ *)data0)[0] +
                                         ((@temptype@ *)data_out)[0];
        ((@temptype@ *)data_out)[1] = ((@temptype@ *)data0)[1] +
                                         ((@temptype@ *)data_out)[1];
        data0 += stride0;
        data_out += stride_out;
#  else
#    if @nop@ <= 3
#define _SUMPROD_NOP @nop@
#    else
#define _SUMPROD_NOP nop
#    endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[0];
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }
}

#if @nop@ == 1

static void
@name@_sum_of_products_contig_one(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data_out = (@type@ *)dataptr[1];

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_one (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
/**begin repeat2
 * #i = 6, 5, 4, 3, 2, 1, 0#
 */
        case @i@+1:
#if !@complex@
            data_out[@i@] = @to@(@from@(data0[@i@]) +
                                 @from@(data_out[@i@]));
#else
            ((@temptype@ *)data_out + 2*@i@)[0] =
                                    ((@temptype@ *)data0 + 2*@i@)[0] +
                                    ((@temptype@ *)data_out + 2*@i@)[0];
            ((@temptype@ *)data_out + 2*@i@)[1] =
                                    ((@temptype@ *)data0 + 2*@i@)[1] +
                                    ((@temptype@ *)data_out + 2*@i@)[1];
#endif
/**end repeat2**/
        case 0:
            return;
    }

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
#if !@complex@
        data_out[@i@] = @to@(@from@(data0[@i@]) +
                             @from@(data_out[@i@]));
#else /* complex */
        ((@temptype@ *)data_out + 2*@i@)[0] =
                                ((@temptype@ *)data0 + 2*@i@)[0] +
                                ((@temptype@ *)data_out + 2*@i@)[0];
        ((@temptype@ *)data_out + 2*@i@)[1] =
                                ((@temptype@ *)data0 + 2*@i@)[1] +
                                ((@temptype@ *)data_out + 2*@i@)[1];
#endif
/**end repeat2**/
        data0 += 8;
        data_out += 8;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif @nop@ == 2 && !@complex@

static void
@name@_sum_of_products_contig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data_out = (@type@ *)dataptr[2];
#if NPY_SIMD && @float32@
    npyv_f32 a, b;
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 a, b;
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_two (%d)\n",
                                                            (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        data_out[count-1] = @to@(@from@(data0[count-1]) *
                                 @from@(data1[count-1]) +
                                 @from@(data_out[count-1]));
    }
    if (count == 0) {
        return;
    }
#if NPY_SIMD && @float32@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1) &&
        EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;
            // two simd pack in one round
            for(int i = 0; i < 2; i++) {
                pack_size = i * UNROLL_BY / 2;
                a = npyv_mul_f32(npyv_loada_f32(data0+pack_size), npyv_loada_f32(data1+pack_size));
                b = npyv_add_f32(a, npyv_loada_f32(data_out+pack_size));
                npyv_storea_f32(data_out+pack_size, b);
            }
            data0 += UNROLL_BY;
            data1 += UNROLL_BY;
            data_out += UNROLL_BY;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1) &&
        EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;
            for (int i  = 0; i < 4; i++) {
                pack_size = i * UNROLL_BY / 4;
                a = npyv_mul_f64(npyv_loada_f64(data0+pack_size), npyv_loada_f64(data1+pack_size));
                b = npyv_add_f64(a, npyv_loada_f64(data_out+pack_size));
                npyv_storea_f64(data_out+pack_size, b);
            }
            data0 += UNROLL_BY;
            data1 += UNROLL_BY;
            data_out += UNROLL_BY;
        }
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by UNROLL_BY */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        for (int i  = 0; i < 2; i++) {
            pack_size = i * UNROLL_BY / 2;
            a = npyv_mul_f32(npyv_load_f32(data0+pack_size), npyv_load_f32(data1+pack_size));
            b = npyv_add_f32(a, npyv_load_f32(data_out+pack_size));
            npyv_store_f32(data_out+pack_size, b);
        }
#elif NPY_SIMD_F64 && @float64@
        for (int i  = 0; i < 4; i++) {
            pack_size = i * UNROLL_BY / 4;
            a = npyv_mul_f64(npyv_load_f64(data0+pack_size), npyv_load_f64(data1+pack_size));
            b = npyv_add_f64(a, npyv_load_f64(data_out+pack_size));
            npyv_store_f64(data_out+pack_size, b);
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        data_out[i] = @to@(@from@(data0[i]) *
                                 @from@(data1[i]) +
                                 @from@(data_out[i]));
    }
#endif
        data0 += UNROLL_BY;
        data1 += UNROLL_BY;
        data_out += UNROLL_BY;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

/* Some extra specializations for the two operand case */
static void
@name@_sum_of_products_stride0_contig_outcontig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @temptype@ value0 = @from@(*(@type@ *)dataptr[0]);
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data_out = (@type@ *)dataptr[2];
#if NPY_SIMD && @float32@
    npyv_f32 a, b, value0_sse;
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 a, b, value0_sse;
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_stride0_contig_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        data_out[count-1] = @to@(value0 *
                                 @from@(data1[count-1]) +
                                 @from@(data_out[count-1]));
    }
    if (count == 0) {
        return;
    }

#if NPY_SIMD && @float32@
    value0_sse = npyv_setall_f32(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data1) && EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 2; i++) {
                pack_size = i * UNROLL_BY / 2;
                a = npyv_mul_f32(value0_sse, npyv_loada_f32(data1+pack_size));
                b = npyv_add_f32(a, npyv_loada_f32(data_out+pack_size));
                npyv_storea_f32(data_out+pack_size, b);
            }
            data1 += UNROLL_BY;
            data_out += UNROLL_BY;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#elif NPY_SIMD_F64 && @float64@
    value0_sse = npyv_setall_f64(value0);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data1) && EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 4; i++) {
                pack_size = i * UNROLL_BY / 4;
                a = npyv_mul_f64(value0_sse, npyv_loada_f64(data1+pack_size));
                b = npyv_add_f64(a, npyv_loada_f64(data_out+pack_size));
                npyv_storea_f64(data_out+pack_size, b);
            }
            data1 += UNROLL_BY;
            data_out += UNROLL_BY;
        }

        /* Finish off the loop */
        if (count > 0) {
            goto finish_after_unrolled_loop;
        }
        else {
            return;
        }
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        for (int i  = 0; i < 2; i++) {
            pack_size = i * UNROLL_BY / 2;
            a = npyv_mul_f32(value0_sse, npyv_load_f32(data1+pack_size));
            b = npyv_add_f32(a, npyv_load_f32(data_out+pack_size));
            npyv_store_f32(data_out+pack_size, b);
        }
#elif NPY_SIMD_F64 && @float64@
        for (int i  = 0; i < 4; i++) {
            pack_size = i * UNROLL_BY / 4;
            a = npyv_mul_f64(value0_sse, npyv_load_f64(data1+pack_size));
            b = npyv_add_f64(a, npyv_load_f64(data_out+pack_size));
            npyv_store_f64(data_out+pack_size, b);
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        data_out[i] = @to@(value0 *
                        @from@(data1[i]) +
                        @from@(data_out[i]));
    }
#endif
        data1 += UNROLL_BY;
        data_out += UNROLL_BY;
    }

    /* Finish off the loop */
    if (count > 0) {
        goto finish_after_unrolled_loop;
    }
}

static void
@name@_sum_of_products_contig_stride0_outcontig_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @temptype@ value1 = @from@(*(@type@ *)dataptr[1]);
    @type@ *data_out = (@type@ *)dataptr[2];
#if NPY_SIMD && @float32@
    npyv_f32 a, b, value1_sse;
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 a, b, value1_sse;
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_stride0_outcontig_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        data_out[count-1] = @to@(@from@(data0[count-1]) *
                                 value1 + @from@(data_out[count-1]));
    }
    if (count == 0) {
        return;
    }

#if NPY_SIMD && @float32@
    value1_sse = npyv_setall_f32(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 2; i++) {
                pack_size = i * UNROLL_BY / 2;
                a = npyv_mul_f32(npyv_loada_f32(data0+pack_size), value1_sse);
                b = npyv_add_f32(a, npyv_loada_f32(data_out+pack_size));
                npyv_storea_f32(data_out+pack_size, b);
            }
            data0 += UNROLL_BY;
            data_out += UNROLL_BY;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    value1_sse = npyv_setall_f64(value1);

    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data_out)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 4; i++) {
                pack_size = i * UNROLL_BY / 4;
                a = npyv_mul_f64(npyv_loada_f64(data0+pack_size), value1_sse);
                b = npyv_add_f64(a, npyv_loada_f64(data_out+pack_size));
                npyv_storea_f64(data_out+pack_size, b);
            }
            data0 += UNROLL_BY;
            data_out += UNROLL_BY;
        }

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        for (int i  = 0; i < 2; i++) {
            pack_size = i * UNROLL_BY / 2;
            a = npyv_mul_f32(npyv_load_f32(data0+pack_size), value1_sse);
            b = npyv_add_f32(a, npyv_load_f32(data_out+pack_size));
            npyv_store_f32(data_out+pack_size, b);
        }
#elif NPY_SIMD_F64 && @float64@
        for (int i  = 0; i < 4; i++) {
            pack_size = i * UNROLL_BY / 4;
            a = npyv_mul_f64(npyv_load_f64(data0+pack_size), value1_sse);
            b = npyv_add_f64(a, npyv_load_f64(data_out+pack_size));
            npyv_store_f64(data_out+pack_size, b);
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        data_out[i] = @to@(@from@(data0[i]) *
                            value1 +
                            @from@(data_out[i]));
    }
#endif
        data0 += UNROLL_BY;
        data_out += UNROLL_BY;
    }

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
@name@_sum_of_products_contig_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @temptype@ accum = 0;
#if NPY_SIMD && @float32@
    npyv_f32 a, accum_sse = npyv_zero_f32();
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 a, accum_sse = npyv_zero_f64();
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        accum += @from@(data0[count-1]) * @from@(data1[count-1]);
    }
    if (count == 0) {
        *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + accum);
        return;
    }

#if NPY_SIMD && @float32@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            npyv_prefetch(data0 + 512, 1);
            npyv_prefetch(data1 + 512, 1);

            /*
             * NOTE: This accumulation changes the order, so will likely
             *       produce slightly different results.
             */
            for (int i  = 0; i < 2; i++) {
                pack_size = i * UNROLL_BY / 2;
                a = npyv_mul_f32(npyv_loada_f32(data0+pack_size), npyv_loada_f32(data1+pack_size));
                accum_sse = npyv_add_f32(accum_sse, a);
            }
            data0 += UNROLL_BY;
            data1 += UNROLL_BY;
        }

        /* Add the four SSE values and put in accum */
        accum = npyv_sum_f32(accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0) && EINSUM_IS_ALIGNED(data1)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;
            npyv_prefetch(data0 + 512, 1);
            npyv_prefetch(data1 + 512, 1);

            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            for (int i  = 0; i < 4; i++) {
                pack_size = i * UNROLL_BY / 4;
                a = npyv_mul_f64(npyv_loada_f64(data0+pack_size), npyv_loada_f64(data1+pack_size));
                accum_sse = npyv_add_f64(accum_sse, a);
            }
            data0 += UNROLL_BY;
            data1 += UNROLL_BY;
        }

        /* Add the two SSE2 values and put in accum */
        accum = npyv_sum_f64(accum_sse);
        
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        npyv_prefetch(data0 + 512, 1);
        npyv_prefetch(data1 + 512, 1);

        for (int i  = 0; i < 2; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 2;
            a = npyv_mul_f32(npyv_load_f32(data0+pack_size), npyv_load_f32(data1+pack_size));
            accum_sse = npyv_add_f32(accum_sse, a);
        }
#elif NPY_SIMD_F64 && @float64@
        npyv_prefetch(data0 + 512, 1);
        npyv_prefetch(data1 + 512, 1);

        for (int i  = 0; i < 4; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 4;
            a = npyv_mul_f64(npyv_load_f64(data0+pack_size), npyv_load_f64(data1+pack_size));
            accum_sse = npyv_add_f64(accum_sse, a);
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        accum += @from@(data0[i]) * @from@(data1[i]);
    }
#endif
        data0 += UNROLL_BY;
        data1 += UNROLL_BY;
    }

#if NPY_SIMD && @float32@
    /* Add the four SSE values and put in accum */
    accum = npyv_sum_f32(accum_sse);
#elif NPY_SIMD_F64 && @float64@
    /* Add the two SSE2 values and put in accum */
    accum = npyv_sum_f64(accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
@name@_sum_of_products_stride0_contig_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @temptype@ value0 = @from@(*(@type@ *)dataptr[0]);
    @type@ *data1 = (@type@ *)dataptr[1];
    @temptype@ accum = 0;
#if NPY_SIMD && @float32@
    npyv_f32 accum_sse = npyv_zero_f32();
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 accum_sse = npyv_zero_f64();
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_stride0_contig_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        accum += @from@(data1[count-1]);
    }
    if (count == 0) {
        *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + value0 * accum);
        return;
    }

#if NPY_SIMD && @float32@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data1)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 2; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 2;
                accum_sse = npyv_add_f32(accum_sse, npyv_loada_f32(data1+pack_size));
            }
            data1 += UNROLL_BY;
        }
        /* Add the four SSE values and put in accum */
        accum = npyv_sum_f32(accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data1)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 4; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 4;
                accum_sse = npyv_add_f64(accum_sse, npyv_loada_f64(data1+pack_size));
            }
            data1 += UNROLL_BY;
        }
        /* Add the two SSE2 values and put in accum */
        accum = npyv_sum_f64(accum_sse);

        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        for (int i  = 0; i < 2; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 2;
            accum_sse = npyv_add_f32(accum_sse, npyv_load_f32(data1+pack_size));
        }
#elif NPY_SIMD_F64 && @float64@
        for (int i  = 0; i < 4; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 4;
            accum_sse = npyv_add_f64(accum_sse, npyv_load_f64(data1+pack_size));
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        accum += @from@(data1[i]);
    }
#endif
        data1 += UNROLL_BY;
    }

#if NPY_SIMD && @float32@
    /* Add the four SSE values and put in accum */
    accum = npyv_sum_f32(accum_sse);
#elif NPY_SIMD_F64 && @float64@
    /* Add the two SSE2 values and put in accum */
    accum = npyv_sum_f64(accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

static void
@name@_sum_of_products_contig_stride0_outstride0_two(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @temptype@ value1 = @from@(*(@type@ *)dataptr[1]);
    @temptype@ accum = 0;
#if NPY_SIMD && @float32@
    npyv_f32 accum_sse = npyv_zero_f32();
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 accum_sse = npyv_zero_f64();
    npy_intp pack_size;
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_stride0_outstride0_two (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
        accum += @from@(data0[count-1]);
    }
    if (count == 0) {
        *(@type@ *)dataptr[2] = @to@(@from@(*(@type@ *)dataptr[2]) + accum * value1);
        return;
    }

#if NPY_SIMD && @float32@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0)) {
        /* Unroll the loop by 8 */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 2; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 2;
                accum_sse = npyv_add_f32(accum_sse, npyv_loada_f32(data0+pack_size));
            }
            data0 += UNROLL_BY;
        }
        /* Add the four SSE values and put in accum */
        accum = npyv_sum_f32(accum_sse);
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            for (int i  = 0; i < 4; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 4;
                accum_sse = npyv_add_f64(accum_sse, npyv_loada_f64(data0+pack_size));
            }
            data0 += UNROLL_BY;
        }
        /* Add the two SSE2 values and put in accum */
        accum = npyv_sum_f64(accum_sse);
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by 8 */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        for (int i  = 0; i < 2; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 2;
            accum_sse = npyv_add_f32(accum_sse, npyv_load_f32(data0+pack_size));
        }
#elif NPY_SIMD_F64 && @float64@
        for (int i  = 0; i < 4; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 4;
            accum_sse = npyv_add_f64(accum_sse, npyv_load_f64(data0+pack_size));
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
        accum += @from@(data0[i]);
    }
#endif
        data0 += UNROLL_BY;
    }

#if NPY_SIMD && @float32@
    /* Add the four SSE values and put in accum */
    accum = npyv_sum_f32(accum_sse);
#elif NPY_SIMD_F64 && @float64@
    /* Add the two SSE2 values and put in accum */
    accum = npyv_sum_f64(accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#elif @nop@ == 3 && !@complex@

static void
@name@_sum_of_products_contig_three(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    @type@ *data0 = (@type@ *)dataptr[0];
    @type@ *data1 = (@type@ *)dataptr[1];
    @type@ *data2 = (@type@ *)dataptr[2];
    @type@ *data_out = (@type@ *)dataptr[3];

    /* Unroll the loop by 8 */
    while (count >= 8) {
        count -= 8;

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        data_out[@i@] = @to@(@from@(data0[@i@]) *
                             @from@(data1[@i@]) *
                             @from@(data2[@i@]) +
                             @from@(data_out[@i@]));
/**end repeat2**/
        data0 += 8;
        data1 += 8;
        data2 += 8;
        data_out += 8;
    }

    /* Finish off the loop */

/**begin repeat2
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
    if (count-- == 0) {
        return;
    }
    data_out[@i@] = @to@(@from@(data0[@i@]) *
                         @from@(data1[@i@]) *
                         @from@(data2[@i@]) +
                         @from@(data_out[@i@]));
/**end repeat2**/
}

#else /* @nop@ > 3 || @complex */

static void
@name@_sum_of_products_contig_@noplabel@(int nop, char **dataptr,
                                npy_intp const *NPY_UNUSED(strides), npy_intp count)
{
    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_@noplabel@ (%d)\n",
                                                    (int)count);

    while (count--) {
#if !@complex@
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        *(@type@ *)dataptr[nop] = @to@(temp +
                                           @from@(*(@type@ *)dataptr[i]));
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(@type@);
        }
#else /* complex */
#  if @nop@ <= 3
#    define _SUMPROD_NOP @nop@
#  else
#    define _SUMPROD_NOP nop
#  endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[0] = re +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[0];
        ((@temptype@ *)dataptr[_SUMPROD_NOP])[1] = im +
                                     ((@temptype@ *)dataptr[_SUMPROD_NOP])[1];

        for (i = 0; i <= _SUMPROD_NOP; ++i) {
            dataptr[i] += sizeof(@type@);
        }
#  undef _SUMPROD_NOP
#endif
    }
}

#endif /* functions for various @nop@ */

#if @nop@ == 1

static void
@name@_sum_of_products_contig_outstride0_one(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if @complex@
    @temptype@ accum_re = 0, accum_im = 0;
    @temptype@ *data0 = (@temptype@ *)dataptr[0];
#else
    @temptype@ accum = 0;
    @type@ *data0 = (@type@ *)dataptr[0];
#endif

#if NPY_SIMD && @float32@
    npyv_f32 accum_sse = npyv_zero_f32();
    npy_intp pack_size;
#elif NPY_SIMD_F64 && @float64@
    npyv_f64 accum_sse = npyv_zero_f64();
    npy_intp pack_size;
#endif


    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_contig_outstride0_one (%d)\n",
                                                    (int)count);

/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    for (; count < UNROLL_BY && count > 0; count--) {
#if !@complex@
            accum += @from@(data0[count-1]);
#else /* complex */
            accum_re += data0[2*(count-1)+0];
            accum_im += data0[2*(count-1)+1];
#endif
    }
    if (count == 0) {
#if @complex@
            ((@temptype@ *)dataptr[1])[0] += accum_re;
            ((@temptype@ *)dataptr[1])[1] += accum_im;
#else
            *((@type@ *)dataptr[1]) = @to@(accum +
                                    @from@(*((@type@ *)dataptr[1])));
#endif
        return;
    }

#if NPY_SIMD && @float32@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            npyv_prefetch(data0 + 512, 1);

            for (int i  = 0; i < 2; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 2;
                accum_sse = npyv_add_f32(accum_sse, npyv_loada_f32(data0+pack_size));
            }
            data0 += UNROLL_BY;
        }
        /* Add the four SSE values and put in accum */
        accum = npyv_sum_f32(accum_sse);
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#elif NPY_SIMD_F64 && @float64@
    /* Use aligned instructions if possible */
    if (EINSUM_IS_ALIGNED(data0)) {
        /* Unroll the loop by UNROLL_BY */
        while (count >= UNROLL_BY) {
            count -= UNROLL_BY;

            npyv_prefetch(data0 + 512, 1);

            for (int i  = 0; i < 4; i++) {
                /*
                * NOTE: This accumulation changes the order, so will likely
                *       produce slightly different results.
                */
                pack_size = i * UNROLL_BY / 4;
                accum_sse = npyv_add_f64(accum_sse, npyv_loada_f64(data0+pack_size));
            }
            data0 += UNROLL_BY;
        }
        accum = npyv_sum_f64(accum_sse);
        /* Finish off the loop */
        goto finish_after_unrolled_loop;
    }
#endif

    /* Unroll the loop by UNROLL_BY */
    while (count >= UNROLL_BY) {
        count -= UNROLL_BY;

#if NPY_SIMD && @float32@
        npyv_prefetch(data0 + 512, 1);

        for (int i  = 0; i < 2; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 2;
            accum_sse = npyv_add_f32(accum_sse, npyv_load_f32(data0+pack_size));
        }
#elif NPY_SIMD_F64 && @float64@
        npyv_prefetch(data0 + 512, 1);

        for (int i  = 0; i < 4; i++) {
            /*
            * NOTE: This accumulation changes the order, so will likely
            *       produce slightly different results.
            */
            pack_size = i * UNROLL_BY / 4;
            accum_sse = npyv_add_f64(accum_sse, npyv_load_f64(data0+pack_size));
        }
#else
    for (int i = 0; i < UNROLL_BY; i++) {
#if !@complex@
        accum += @from@(data0[i]);
#else /* complex */
        accum_re += data0[2*i+0];
        accum_im += data0[2*i+1];
#endif
    }
#endif

#if !@complex@
        data0 += UNROLL_BY;
#else
        data0 += UNROLL_BY*2;
#endif
    }

#if NPY_SIMD && @float32@
    /* Add the four SSE values and put in accum */
    accum = npyv_sum_f32(accum_sse);
#elif NPY_SIMD_F64 && @float64@
    /* Add the two SSE2 values and put in accum */
    accum = npyv_sum_f64(accum_sse);
#endif

    /* Finish off the loop */
    goto finish_after_unrolled_loop;
}

#endif /* @nop@ == 1 */

static void
@name@_sum_of_products_outstride0_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if @complex@
    @temptype@ accum_re = 0, accum_im = 0;
#else
    @temptype@ accum = 0;
#endif

#if (@nop@ == 1) || (@nop@ <= 3 && !@complex@)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3) && !@complex@
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3) && !@complex@
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    NPY_EINSUM_DBG_PRINT1("@name@_sum_of_products_outstride0_@noplabel@ (%d)\n",
                                                    (int)count);

    while (count--) {
#if !@complex@
#  if @nop@ == 1
        accum += @from@(*(@type@ *)data0);
        data0 += stride0;
#  elif @nop@ == 2
        accum += @from@(*(@type@ *)data0) *
                 @from@(*(@type@ *)data1);
        data0 += stride0;
        data1 += stride1;
#  elif @nop@ == 3
        accum += @from@(*(@type@ *)data0) *
                 @from@(*(@type@ *)data1) *
                 @from@(*(@type@ *)data2);
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#  else
        @temptype@ temp = @from@(*(@type@ *)dataptr[0]);
        int i;
        for (i = 1; i < nop; ++i) {
            temp *= @from@(*(@type@ *)dataptr[i]);
        }
        accum += temp;
        for (i = 0; i < nop; ++i) {
            dataptr[i] += strides[i];
        }
#  endif
#else /* complex */
#  if @nop@ == 1
        accum_re += ((@temptype@ *)data0)[0];
        accum_im += ((@temptype@ *)data0)[1];
        data0 += stride0;
#  else
#    if @nop@ <= 3
#define _SUMPROD_NOP @nop@
#    else
#define _SUMPROD_NOP nop
#    endif
        @temptype@ re, im, tmp;
        int i;
        re = ((@temptype@ *)dataptr[0])[0];
        im = ((@temptype@ *)dataptr[0])[1];
        for (i = 1; i < _SUMPROD_NOP; ++i) {
            tmp = re * ((@temptype@ *)dataptr[i])[0] -
                  im * ((@temptype@ *)dataptr[i])[1];
            im = re * ((@temptype@ *)dataptr[i])[1] +
                 im * ((@temptype@ *)dataptr[i])[0];
            re = tmp;
        }
        accum_re += re;
        accum_im += im;
        for (i = 0; i < _SUMPROD_NOP; ++i) {
            dataptr[i] += strides[i];
        }
#undef _SUMPROD_NOP
#  endif
#endif
    }

#if @complex@
#  if @nop@ <= 3
    ((@temptype@ *)dataptr[@nop@])[0] += accum_re;
    ((@temptype@ *)dataptr[@nop@])[1] += accum_im;
#  else
    ((@temptype@ *)dataptr[nop])[0] += accum_re;
    ((@temptype@ *)dataptr[nop])[1] += accum_im;
#  endif
#else
#  if @nop@ <= 3
    *((@type@ *)dataptr[@nop@]) = @to@(accum +
                                    @from@(*((@type@ *)dataptr[@nop@])));
#  else
    *((@type@ *)dataptr[nop]) = @to@(accum +
                                    @from@(*((@type@ *)dataptr[nop])));
#  endif
#endif

}

/**end repeat1**/

/**end repeat**/


/* Do OR of ANDs for the boolean type */

/**begin repeat
 * #nop = 1, 2, 3, 1000#
 * #noplabel = one, two, three, any#
 */

static void
bool_sum_of_products_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif
#if (@nop@ <= 3)
    char *data_out = dataptr[@nop@];
    npy_intp stride_out = strides[@nop@];
#endif

    while (count--) {
#if @nop@ == 1
        *(npy_bool *)data_out = *(npy_bool *)data0 ||
                                  *(npy_bool *)data_out;
        data0 += stride0;
        data_out += stride_out;
#elif @nop@ == 2
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data_out += stride_out;
#elif @nop@ == 3
        *(npy_bool *)data_out = (*(npy_bool *)data0 &&
                                   *(npy_bool *)data1 &&
                                   *(npy_bool *)data2) ||
                                   *(npy_bool *)data_out;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
        data_out += stride_out;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }
}

static void
bool_sum_of_products_contig_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
#if (@nop@ <= 3)
    char *data0 = dataptr[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
#endif
#if (@nop@ <= 3)
    char *data_out = dataptr[@nop@];
#endif

#if (@nop@ <= 3)
/* This is placed before the main loop to make small counts faster */
finish_after_unrolled_loop:
    switch (count) {
/**begin repeat1
 * #i = 6, 5, 4, 3, 2, 1, 0#
 */
        case @i@+1:
#  if @nop@ == 1
            ((npy_bool *)data_out)[@i@] = ((npy_bool *)data0)[@i@] ||
                                            ((npy_bool *)data_out)[@i@];
#  elif @nop@ == 2
            ((npy_bool *)data_out)[@i@] =
                            (((npy_bool *)data0)[@i@] &&
                             ((npy_bool *)data1)[@i@]) ||
                                ((npy_bool *)data_out)[@i@];
#  elif @nop@ == 3
            ((npy_bool *)data_out)[@i@] =
                           (((npy_bool *)data0)[@i@] &&
                            ((npy_bool *)data1)[@i@] &&
                            ((npy_bool *)data2)[@i@]) ||
                                ((npy_bool *)data_out)[@i@];
#  endif
/**end repeat1**/
        case 0:
            return;
    }
#endif

/* Unroll the loop by 8 for fixed-size nop */
#if (@nop@ <= 3)
    while (count >= 8) {
        count -= 8;
#else
    while (count--) {
#endif

#  if @nop@ == 1
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) = (*((npy_bool *)data0 + @i@)) ||
                                        (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif @nop@ == 2
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) =
                        ((*((npy_bool *)data0 + @i@)) &&
                         (*((npy_bool *)data1 + @i@))) ||
                            (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  elif @nop@ == 3
/**begin repeat1
 * #i = 0, 1, 2, 3, 4, 5, 6, 7#
 */
        *((npy_bool *)data_out + @i@) =
                       ((*((npy_bool *)data0 + @i@)) &&
                        (*((npy_bool *)data1 + @i@)) &&
                        (*((npy_bool *)data2 + @i@))) ||
                            (*((npy_bool *)data_out + @i@));
/**end repeat1**/
        data0 += 8*sizeof(npy_bool);
        data1 += 8*sizeof(npy_bool);
        data2 += 8*sizeof(npy_bool);
        data_out += 8*sizeof(npy_bool);
#  else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        *(npy_bool *)dataptr[nop] = temp || *(npy_bool *)dataptr[i];
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += sizeof(npy_bool);
        }
#  endif
    }

    /* If the loop was unrolled, we need to finish it off */
#if (@nop@ <= 3)
    goto finish_after_unrolled_loop;
#endif
}

static void
bool_sum_of_products_outstride0_@noplabel@(int nop, char **dataptr,
                                npy_intp const *strides, npy_intp count)
{
    npy_bool accum = 0;

#if (@nop@ <= 3)
    char *data0 = dataptr[0];
    npy_intp stride0 = strides[0];
#endif
#if (@nop@ == 2 || @nop@ == 3)
    char *data1 = dataptr[1];
    npy_intp stride1 = strides[1];
#endif
#if (@nop@ == 3)
    char *data2 = dataptr[2];
    npy_intp stride2 = strides[2];
#endif

    while (count--) {
#if @nop@ == 1
        accum = *(npy_bool *)data0 || accum;
        data0 += stride0;
#elif @nop@ == 2
        accum = (*(npy_bool *)data0 && *(npy_bool *)data1) || accum;
        data0 += stride0;
        data1 += stride1;
#elif @nop@ == 3
        accum = (*(npy_bool *)data0 &&
                 *(npy_bool *)data1 &&
                 *(npy_bool *)data2) || accum;
        data0 += stride0;
        data1 += stride1;
        data2 += stride2;
#else
        npy_bool temp = *(npy_bool *)dataptr[0];
        int i;
        for (i = 1; i < nop; ++i) {
            temp = temp && *(npy_bool *)dataptr[i];
        }
        accum = temp || accum;
        for (i = 0; i <= nop; ++i) {
            dataptr[i] += strides[i];
        }
#endif
    }

#  if @nop@ <= 3
    *((npy_bool *)dataptr[@nop@]) = accum || *((npy_bool *)dataptr[@nop@]);
#  else
    *((npy_bool *)dataptr[nop]) = accum || *((npy_bool *)dataptr[nop]);
#  endif
}

/**end repeat**/

typedef void (*sum_of_products_fn)(int, char **, npy_intp const*, npy_intp);

/* These tables need to match up with the type enum */
static sum_of_products_fn
_contig_outstride0_unary_specialization_table[NPY_NTYPES] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 0,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
    &@name@_sum_of_products_contig_outstride0_one,
#else
    NULL,
#endif
/**end repeat**/
}; /* End of _contig_outstride0_unary_specialization_table */

static sum_of_products_fn _binary_specialization_table[NPY_NTYPES][5] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 0,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        0, 0, 0,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_stride0_contig_outstride0_two,
    &@name@_sum_of_products_stride0_contig_outcontig_two,
    &@name@_sum_of_products_contig_stride0_outstride0_two,
    &@name@_sum_of_products_contig_stride0_outcontig_two,
    &@name@_sum_of_products_contig_contig_outstride0_two,
},
#else
    {NULL, NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _binary_specialization_table */

static sum_of_products_fn _outstride0_specialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_outstride0_any,
    &@name@_sum_of_products_outstride0_one,
    &@name@_sum_of_products_outstride0_two,
    &@name@_sum_of_products_outstride0_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _outstride0_specialized_table */

static sum_of_products_fn _allcontig_specialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_contig_any,
    &@name@_sum_of_products_contig_one,
    &@name@_sum_of_products_contig_two,
    &@name@_sum_of_products_contig_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _allcontig_specialized_table */

static sum_of_products_fn _unspecialized_table[NPY_NTYPES][4] = {
/**begin repeat
 * #name = bool,
 *         byte, ubyte,
 *         short, ushort,
 *         int, uint,
 *         long, ulong,
 *         longlong, ulonglong,
 *         float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, string, unicode, void,
 *         datetime, timedelta, half#
 * #use = 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1,
 *        1, 1, 1,
 *        1, 1, 1,
 *        0, 0, 0, 0,
 *        0, 0, 1#
 */
#if @use@
{
    &@name@_sum_of_products_any,
    &@name@_sum_of_products_one,
    &@name@_sum_of_products_two,
    &@name@_sum_of_products_three
},
#else
    {NULL, NULL, NULL, NULL},
#endif
/**end repeat**/
}; /* End of _unnspecialized_table */

NPY_NO_EXPORT sum_of_products_fn NPY_CPU_DISPATCH_CURFX(einsum_get_sum_of_products_function)
(int nop, int type_num, npy_intp itemsize,npy_intp const *fixed_strides)
{
    int iop;

    if (type_num >= NPY_NTYPES) {
        return NULL;
    }

    /* contiguous reduction */
    if (nop == 1 && fixed_strides[0] == itemsize && fixed_strides[1] == 0) {
        sum_of_products_fn ret =
            _contig_outstride0_unary_specialization_table[type_num];
        if (ret != NULL) {
            return ret;
        }
    }

    /* nop of 2 has more specializations */
    if (nop == 2) {
        /* Encode the zero/contiguous strides */
        int code;
        code = (fixed_strides[0] == 0) ? 0 :
                    (fixed_strides[0] == itemsize) ? 2*2*1 : 8;
        code += (fixed_strides[1] == 0) ? 0 :
                    (fixed_strides[1] == itemsize) ? 2*1 : 8;
        code += (fixed_strides[2] == 0) ? 0 :
                    (fixed_strides[2] == itemsize) ? 1 : 8;
        if (code >= 2 && code < 7) {
            sum_of_products_fn ret =
                        _binary_specialization_table[type_num][code-2];
            if (ret != NULL) {
                return ret;
            }
        }
    }

    /* Inner loop with an output stride of 0 */
    if (fixed_strides[nop] == 0) {
        return _outstride0_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* Check for all contiguous */
    for (iop = 0; iop < nop + 1; ++iop) {
        if (fixed_strides[iop] != itemsize) {
            break;
        }
    }

    /* Contiguous loop */
    if (iop == nop + 1) {
        return _allcontig_specialized_table[type_num][nop <= 3 ? nop : 0];
    }

    /* None of the above specializations caught it, general loops */
    return _unspecialized_table[type_num][nop <= 3 ? nop : 0];
}
